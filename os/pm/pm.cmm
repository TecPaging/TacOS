/*
 * TacOS Source Code
 *    Tokuyama kousen Advanced educational Computer.
 *
 * Copyright (C) 2024 by
 *                      Dept. of Computer Science and Electronic Engineering,
 *                      Tokuyama College of Technology, JAPAN
 *
 *   上記著作権者は，Free Software Foundation によって公開されている GNU 一般公
 * 衆利用許諾契約書バージョン２に記述されている条件を満たす場合に限り，本ソース
 * コード(本ソースコードを改変したものを含む．以下同様)を使用・複製・改変・再配
 * 布することを無償で許諾する．
 *
 *   本ソースコードは＊全くの無保証＊で提供されるものである。上記著作権者および
 * 関連機関・個人は本ソースコードに関して，その適用可能性も含めて，いかなる保証
 * も行わない．また，本ソースコードの利用により直接的または間接的に生じたいかな
 * る損害に関しても，その責任を負わない．
 *
 *
 */

/*
 * pm/pm.cmm : PM のユーザプロセスコンテキストで実行される部分
 *
 * 2024.01.18 : 旧の pm.cmm から分離
 */

#include <errno.hmm>
#include <util.hmm>                                 // _memSizの宣言はこの中
#include <kernel.hmm>
#include <dispatcher.hmm>
#include <syscall.hmm>
#include <mm.hmm>
#include <fs.hmm>
//#include <file.hmm>
#include "pm.hmm"
#include "pmServer.hmm"                             // pm.cmm と pmServer.cmm
                                                    //  で共有するもの
#include "frame.hmm"
//#include "exeFile.hmm"

#define MMU_TblReg   0xa6                           // ページテーブルレジスタ
#define MMU_FltPage  0xa6                           // ページ例外の原因ページ
#define MMU_FltAdr   0xa2                           // ページ例外の原因アドレス
//-----------------------------------------------------------------------------
// ユーザプロセスのシステムコール入口
//   以下は、ユーザプロセスのコンテキストで実行されるので、
//   原則 PM のグローバル変数にアクセスしてはならない
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  LOAD, RELEASE システムコール
//   swap-inを行いSticky(S)ビットをONにする/(S)ビットをOFFにする
//-----------------------------------------------------------------------------
public int load(int vAdr) {
  int r = sndrec(pmLink, LOAD, vAdr, 0, 0);
  return r;
}

public int release(int vAdr) {
  int[] pageTable = curProc.pageTable;              // プロセスのページテーブル
  int pNum = adrToPage(vAdr);                       // ページ番号
  pageTable[pNum] = pageTable[pNum] & ~SBIT;        // sticky(S)ビットをOFFに
  return 0;                                         // 成功
}

//-----------------------------------------------------------------------------
// peekS, peekM, pokeM システムコール
//-----------------------------------------------------------------------------
public char[] peekS(int vAdr) {
   int str = sndrec(pmLink, PEEKS, vAdr, 0, 0);
   return _ItoA(str);
}

public int peekM(int vAdr, void[] pAdr, int size) {
  int r = sndrec(pmLink, PEEKM, vAdr, _AtoI(pAdr), size);
  return r;
}

public int pokeM(int vAdr, void[] pAdr, int size) {
  int r = sndrec(pmLink, POKEM, vAdr, _AtoI(pAdr), size);
  return r;
}

//-----------------------------------------------------------------------------
// exec システムコールはサーバプロセスに処理させる
//-----------------------------------------------------------------------------
// init が呼び出す exec システムコール
public int exec(char[] path, char[][] argv, char[][] envp) {
#ifdef DEBUG
  printF("exec(path=%s)\n", path);
#endif
  int r=sndrec(pmLink, EXEC, _AtoI(path), _AtoI(argv), _AtoI(envp));
  return r;
}

// ユーザ用の exec システムコール
public int _exec(char[] path, char[][] argv, char[][] envp) {
  char[] str = peekS(_AtoI(path));                  // pmのシステムコール
  if (str==null) return ENOMEM;                     // メモリ不足
  int r=exec(str, argv, envp);
  free(str);
  return r;                                         // 新しい子の PID を返す
}

//-----------------------------------------------------------------------------
// exit システムコールはユーザプロセスが自ら処理する
// （ユーザプロセスのコンテキストで実行）
//-----------------------------------------------------------------------------
// ページテーブルと参照しているフレームを解放する
void freePageTable(PCB pcb) {
  int[] pageTable = pcb.pageTable;                  // ページテーブルのアドレス
  // フレームの解放
  for (int pNum=0; pNum<TOTALPAGE; pNum=pNum+1) {   // ページテーブルのidx
    int entry = pageTable[pNum];
    if ((entry&VBIT)!=0) {                          // Vビットが1なら
      releaseFrame(entry & FBITS);                  // フレーム解放
      // tlbPid = 0;                                // dispatch時にTLBをflush
                                                    //  exitしたからflush不要
    }
  }
  // ページテーブルの解放
  int fNum =  adrToFrame(_AtoI(pageTable));         // アドレスのフレーム番号
  releaseFrame(fNum);                               // フレームを解放
  releaseFrame(fNum+1);                             // 2フレーム目を解放
}

// 現在のプロセスをゾンビにする(カレントプロセスが exit の後半で呼出す)
void zmbProc() {
  int r = setPri(DI|KERN);                          // 割り込み禁止、カーネル

  // もしタイマーが稼働中なら止める
  // if (curProc.evtCnt>0) ...  将来 alarm を実装すると必要になる？

  // 子プロセスの親を INIT に変更する
  for (int i=0; i<PRC_MAX; i=i+1) {
    PCB p = procTbl[i];                             // 全プロセスについて
    if (p!=null && p.parent==curProc)               //   自分の子プロセスなら
      p.parent = initProc;                          //     親を INIT に変更する
  }

  // もし親プロセスが先に wait していたら起こす
  if (curProc.parent.evtCnt == -1)                  // 親が wait していたら
    iSemV(curProc.parent.evtSem);                   //   V 操作で起こす

  // 自身の PCB を後片付けしプロセスを終了
  freeSem(curProc.evtSem);                          // セマフォを返却し
  delProc(curProc);                                 // 実行可能列から外す
  curProc.stat = P_ZOMBIE;                          // ゾンビに変更
  yield();                                          // CPUを解放する
  panic("zmbProc");                                 // ゾンビが生き返った
}

public void exit(int status) {
  for (int i=0; i<P_FILE_MAX; i=i+1)                // クローズ忘れがあれば
    if (curProc.fds[i]!=-1) close(i);               //   クローズする
  sndrec(pmLink, CLOSEEXE, curProc.filedsc, 0, 0);  // exeファイルを閉じる
#ifdef DEBUG
  printF("exit(closeFD=%d)\n", curProc.filedsc);
#endif
  freePageTable(curProc);                           // ページテーブルを捨てる
  curProc.exitStat = status;                        // 終了ステータスを格納
  zmbProc();                                        // 自身をゾンビにする
  //panic("exit");  ここは実行されない
}

//-----------------------------------------------------------------------------
// wait システムコールはユーザプロセスが自ら処理する
// （ユーザプロセスのコンテキストで実行）
//-----------------------------------------------------------------------------
// 現在のプロセスの子プロセスの PCB を返す(割込み禁止で呼出す)
//   ZOMBIE の子プロセスがあれば優先的に選択しそれの PCB を返す
//   子プロセスが全く存在しない場合は null を返す
PCB srchChild() {
  PCB child = null;                                 // 子プロセスなし
  for(int i=0; i<PRC_MAX; i=i+1) {                  // 全てのプロセスについて
    PCB p = procTbl[i];                             //   子プロセスかチェック
    if(p!=null && p.parent==curProc) {              //     子プロセスを発見
      child = p;                                    //       子プロセスあり
      if(p.stat==P_ZOMBIE)                          //       ゾンビ(exit 済)なら
        break;                                      //         これで決定
    }
  }
  return child;
}

// 終了した子プロセスを見つけ procTbl[] から抹消した後で PCB を返す
//   子プロセスが存在しない場合は null を返す
//   自身が wait システムコールの処理から呼出す
PCB waitChild() {
  int r = setPri(DI|KERN);                          // 割り込み禁止、カーネル
  PCB p = srchChild();                              // 子プロセスを探す
  if (p!=null && p.stat!=P_ZOMBIE) {                // 子プロセスあるが
    curProc.evtCnt = -1;                            //   ゾンビではない
    semP(curProc.evtSem);                           //  子プロセス待ち状態
    p = srchChild();                                //  子プロセスを探す
    if (p==null || p.stat!=P_ZOMBIE)                //  ゾンビな子が居ないのに
      panic("waitChild");                           //    起こされたら OS にバグ
  }
  if (p!=null)                                      // 子プロセスが見つかった
    procTbl[p.idx] = null;                          // エントリを削除する
  setPri(r);                                        // 割り込み状態を復元する
  return p;
}

public int wait(int[] sta) {
  int r = ECHILD;                                   // 一旦、エラー番号を設定
  PCB child = waitChild();                          // 子プロセスの終了を待つ
  if (child!=null) {                                // 子プロセスが終了した
    sta[0] = child.exitStat;                        //   終了ステータスをコピー
    r = child.pid;                                  //   free する前に記録
    free(child);                                    //   PCB 領域を解放する
  }
  return r;                                         // 終了したプロセスの PID
}

public int _wait(int[] sta) {                       // ユーザプロセス用の入り口
  int[] buf = malloc(sizeof(int));                  // 物理メモリを確保
  if (buf==null) return ENOMEM;                     // メモリ不足
  int r = wait(buf);                                // システムコール本体を実行
  if (r>=0) {                                       // エラーでなければ
    sndrec(pmLink, POKEW, _AtoI(sta), buf[0], 0);   //   ステータスを書き込む
  }
  free(buf);                                        // 物理メモリを解放
  return r;                                         // 終了したプロセスの PID
}

//-----------------------------------------------------------------------------
// ページ例外はユーザプロセスが処理する（ユーザプロセスのコンテキストで実行）
// ！！ただし，swap-inが必要な場合はPMに切り換わるので要注意！！
//-----------------------------------------------------------------------------
public interrupt pageFlt() {                        // ページ例外ハンドラ
  int[] pageTable = curProc.pageTable;              // ページテーブルのアドレス
  int pNum = in(MMU_FltPage);                       // 原因ページの番号
#ifdef DEBUG
  int fAdr = in(MMU_FltAdr);                        // 原因アドレス
  printF("pageFault(fltAdr=%04x,pid=%d)\n", fAdr, curProc.pid);
#endif

  // 該当ページをswap-inする
  int pAdr = load(pNum*PAGESIZ);                    //  PMにswap-inさせる
  if (pAdr==0) panic("pageFlt");                    //  失敗したらパニック
  release(pNum*PAGESIZ);                            //  SビットをOFFにする
}
