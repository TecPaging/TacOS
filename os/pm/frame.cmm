/*
 * TacOS Source Code
 *    Tokuyama kousen Advanced educational Computer.
 *
 * Copyright (C) 2023 by
 *                      Dept. of Computer Science and Electronic Engineering,
 *                      Tokuyama College of Technology, JAPAN
 *
 *   上記著作権者は，Free Software Foundation によって公開されている GNU 一般公
 * 衆利用許諾契約書バージョン２に記述されている条件を満たす場合に限り，本ソース
 * コード(本ソースコードを改変したものを含む．以下同様)を使用・複製・改変・再配
 * 布することを無償で許諾する．
 *
 *   本ソースコードは＊全くの無保証＊で提供されるものである。上記著作権者および
 * 関連機関・個人は本ソースコードに関して，その適用可能性も含めて，いかなる保証
 * も行わない．また，本ソースコードの利用により直接的または間接的に生じたいかな
 * る損害に関しても，その責任を負わない．
 *
 *
 */

/*
 * pm/frame.cmm : プロセスマネージャ(PM)のページ割り付けアルゴリズム
 *                （フレーム管理）
 *
 * 2023.12.31 : pm.cmm から分離
 */

#include <util.hmm>
#include <kernel.hmm>
#include <dispatcher.hmm>
#include <process.hmm>
#include <mm.hmm>
#include <pm.hmm>
#include "frame.hmm"

//-----------------------------------------------------------------------------
// フレームプール管理のデータ構造
//-----------------------------------------------------------------------------
int krnFrm;                                         // カーネルのフレーム数
int numFrm;                                         // 利用可能なフレーム数

// ページ置換えアルゴリズムにFIFO方式を使う
// FIFOのデータ構造は番兵付きの双方向環状リスト
// fwdLst[0]とbwdLst[0]がFIFOの番兵
char[] fwdLst;                                      // フレームの順向きリスト
char[] bwdLst;                                      // フレームの逆向きリスト
#define SENTINEL 0                                  // 番兵は第0スロットを使用

// フレームが割当てられたプロセスとページ
// フレームの所有プロセスはプロセステーブルのスロット番号で表現する
char[] owner;                                       // フレームの所有プロセス
#define NONE chr(0)                                 // 空きフレーム
#define SYS  chr(1)                                 // ページテーブルなど
                                                    // 5以上がユーザプロセス
char[] page;                                        // フレームの割当ページ

// フレーム番号とFIFOデータ構造の添字の相互変換
#define idxToFnum(idx) ((idx) + krnFrm - 1)         // リスト添字->フレーム番号
#define fNumToIdx(fNum) ((fNum) - krnFrm + 1)       // フレーム番号->リスト添字

//-----------------------------------------------------------------------------
// フレームプールの操作関数
//-----------------------------------------------------------------------------
// 双方向リストからフレームを削除する
void delLst(int fIdx) {
  int next = fwdLst[fIdx];
  int prev = bwdLst[fIdx];
  fwdLst[prev] = chr(next);
  bwdLst[next] = chr(prev);
}

// 双方向リストのnextの前にフレームを挿入する
void insLst(int fIdx, int next) {
  int prev = bwdLst[next];
  fwdLst[fIdx] = chr(next);
  bwdLst[fIdx] = chr(prev);
  fwdLst[prev] = chr(fIdx);
  bwdLst[next] = chr(fIdx);
}

// 仮想メモリ用のフレームを空きフレームから割り付け(FIFOに入れる)
public int assignFrame(int pNum, PCB pcb) {
#ifdef DEBUG
  printF("assignFrame(page=%02x,pid=%d,", pNum, pcb.pid);
#endif
  int fNum = 0;
  int r = setPri(DI|KERN);                          // 排他のため
  for (int i=1; i<=numFrm; i=i+1) {
    if (owner[i]==NONE) {                           // 空きフレームを見つけた
      insLst(i, SENTINEL);                          //  FIFOの最後に追加
      owner[i] = chr(pcb.idx);                      //  所有プロセスを記録
      page[i] = chr(pNum);                          //  割当られたページを記録
      fNum = idxToFnum(i);                          //  フレーム番号に変換
      break;                                        //  見つかった
    }
  }
#ifdef DEBUG
  printF("frame=%02x)\n", fNum);
#endif
  setPri(r);
  return fNum;                                      // フレームを返す
}                                                   //  無い場合は0を返す

// FIFOとページテーブルからフレーム削除(仮想メモリ用，ページテーブル用の兼用)
//  FIFOに入っていないフレームを指定してよびだされることもある
void relFrame(int idx) {                            // 指定したフレームを開放
  int slot = owner[idx];                            // フレームの所有者
  if (slot!=NONE && slot!=SYS) {                    // 仮想メモリ用フレームなら
    PCB pcb = procTbl[idx];                         //  所有プロセスの
    pcb.pageTable[ord(page[idx])] = 0;              //   ページテーブルクリア
    delLst(idx);                                    //  FIFOから削除する
  }
  owner[idx] = NONE;                                // フレームは空き
}

// フレームの解放
public void releaseFrame(int fNum) {                // 指定したフレームを開放
#ifdef DEBUG
  printF("releaseFrame(%02x)\n", fNum);
#endif
  int r = setPri(DI|KERN);                          // 排他のため
  relFrame(fNumToIdx(fNum));                        // フレームの解放
  setPri(r);
}

// 解放できるフレームか？
boolean canRelease(int idx) {
  int slot = owner[idx];                            // 所有プロセスのスロット
  if (slot==SYS) return false;                      // フレームはシステム用
  PCB pcb = procTbl[slot];                          // フレームの所有プロセス
  int entry = pcb.pageTable[ord(page[idx])];        // ページテーブルを読む
  return (entry & (SBIT|WTBIT))==0;                 // S=0 && W=0 なら解放可
}

// ページテーブル用の連続2フレームの割り付け(FIFOに入れない)
public int assignPagTbl() {                         // 2連続フレームの割り当て
#ifdef DEBUG
  printF("assignPagTbl(");
#endif
  int r = setPri(DI|KERN);                          // 排他のため
  int idx = 0;                                      // 連続フレームの候補
  // 連続した空きフレームを探す
  for (int i=1; i<numFrm; i=i+1) {                  // 全フレームについて
    if (owner[i]==NONE && owner[i+1]==NONE) {       //  連続した2フレームが空き
      idx = i;                                      //   この2フレームを
      break;                                        //    使用することが確定
    }
  }
  // 見つからないなら解放可能フレームや空きフレームの連続を探す
  // （空きフレームとの組合せを優先する）
  if (idx==0) {                                     // 見つからないなら
    // FIFOの全フレームについて
    for (int i=fwdLst[SENTINEL]; i!=SENTINEL; i=fwdLst[i]) {
      if (canRelease(i)) {                          //  解放可能で
        if (owner[i-1]==NONE) {                     //   前隣が空きなら
          idx = i - 1;                              //    前隣と2フレームを
          break;                                    //     使用することに確定
        } else if(owner[i+1]==NONE){                //   後隣が空きなら
          idx = i;                                  //    後隣と2フレームを
          break;                                    //     使用することに確定
        } else if (idx==0 && canRelease(i-1)) {     //   候補なし前隣が解放可能
          idx = i - 1;                              //    前隣と2フレームが候補
        } else if (idx==0 && canRelease(i+1)) {     //   候補なし後隣が解放可能
          idx = i;                                  //    後隣と2フレームが候補
        }
      }
    }
  }
  // 仕上げの処理
  int fNum = 0;                                     // 返すフレーム番号
  if (idx!=0) {                                     // 見つかったなら
    relFrame(idx);                                  //  FIFOに入っているなら
    relFrame(idx+1);                                //   FIFOから取り出す
    owner[idx]=owner[idx+1]=SYS;                    //  システムが使用中
    fNum = idxToFnum(idx);                          //  フレーム番号に変換
  }
#ifdef DEBUG
  printF("%02x,%02x)\n", fNum, fNum+1);
#endif
  setPri(r);
  return fNum;                                      // フレーム番号を返す
}

// FIFOから解放できるフレームを捜して取り出し目的のプロセスに割り付ける
public int reuseFrame(int pNum, PCB pcb) {
  int r = setPri(DI|KERN);                          // 排他のため
  int fNum = 0;                                     // 見つけたフレーム
  // FIFOの全フレームについて
  for (int i=fwdLst[SENTINEL]; i!=SENTINEL; i=fwdLst[i]) {
    if (canRelease(i)) {                            //  解放可能なフレームなら
      relFrame(i);                                  //   pagTableクリア,FIFO削除
      insLst(i, SENTINEL);                          //   FIFOの最後へ追加
      owner[i] = chr(pcb.idx);                      //   新しいプロセスを記録
      page[i]  = chr(pNum);                         //   新しいページを記録
      fNum = idxToFnum(i);                          //   フレーム番号に変換
      break;                                        //   見つかった
    }
  }
  setPri(r);
#ifdef DEBUG
  printF("reuseFrame(page=%02x,pid=%d,frame=%02x)\n", pNum, pcb.pid, fNum);
#endif
  return fNum;
}

// フレームプールの初期化（mmを使用するので実行順に注意）
public void frameInit() {
  krnFrm = adrToPage(_memSiz);                      // カーネルのフレーム数
  numFrm = 255 - krnFrm;                            // フレームプールの大きさ
                                                    //  (ベクタ領域を除く)
  // 使用中フレームのFIFOは双方向環状リスト
  fwdLst = malloc(numFrm+1);                        // 順方向リスト(番兵あり)
  bwdLst = malloc(numFrm+1);                        // 逆方向リスト(番兵あり)
  fwdLst[SENTINEL] = chr(SENTINEL);                 // 0番目は番兵として使用
  bwdLst[SENTINEL] = chr(SENTINEL);                 // FIFOは空に初期化

  // フレームが割り当てられたプロセスとページ
  owner = malloc(numFrm+2);                         // 添字処理の都合で大きく
  page  = malloc(numFrm+1);
  for (int i=1; i<=numFrm; i=i+1) {
    owner[i]  = NONE;                               // フレームは未使用
  }
  owner[SENTINEL] = owner[numFrm+1] = SYS;          // これらはシステムが使用中
}
